import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		// N명의 사람과 N명의 일
		int N = sc.nextInt();
		
		// i번 사람이 j번 일을 할 때 필요한 비용
		int[][] costs = new int[N + 1][N + 1];
		for(int i = 1; i <= N; i++) {
			for(int j = 1; j <= N; j++) {
				costs[i][j] = sc.nextInt();
			}
		}
		
		// 예제 1을 기준으로
		// 2 3 3
		// 3 2 3
		// 3 3 2
		// bit로 얼만큼 3개의 일중 얼마나 했는지 기록한다
		// 하나도 안 한 000 부터 ~ 3개를 다 한 111 까지 (0부터 2^N - 1까지)
		// [r의 사람까지 일을 했을 때][c의 bit로 어떤 일을 했는지 기록] = 의 최솟값
		
		// 000 001 010 011 비트로 하면
		// 1번, 2번, 12번, 3번 일을 했을 때 순서로 간다
		// 헷갈리니까 순서대로 보자면
		// 0개의 일, 1번, 2번, 3번, 12번, 13번, 23번, 123번
		// 1번 사람이 일을 한 걸 넣으면 2 3 3 이 된다
		// 2번 사람은 1번 사람이 초기화 시킨 거에서만 올 수 있다
		// 2번 사람이 12번 일을 하는 최솟값을 1번 사람이 한 일에서 더해서
		// 1사람이 1번일 2 -> 2사람까지 12번 4
		// 1사람이 2번일 3 -> 2사람까지 12번 6
		// 둘을 비교해서 최소인 4를 넣는다
		
		// 직전사람이 'j조합의 일에서 빼기 1~N번의 일을 안 했을 때의 값'
		// 더하기 내가 '1~N번 일을 했을 때의 값'
		// 중에서 최솟값을 저장한다
		// -> 이렇게 하면 모든 j의 조합마다 1~N번의 일을 확인해야한다
		// -> 현재 i사람을 기준으로 하는 게 아니라, i-1이 값이 있는 거에서 올라온다

		// 1번 사람이 일을 해서 2 3 3을 넣었을 때
		// 1사람이 일한 거에서 + 2사람이 1번 2번 3번 일했을 때를 더해서 최솟값 갱신
		// 2사람까지 일한 거에서 + 3사람이 1번 2번 3번 일했을 때를 더해서 최솟값 갱신
		// -> 이렇게하면 i-1사람이 값이 있는거에서만 1~N번의 일을 확인한다
		
		// 제로 인덱스 아니고 1번 일을 했으면 10인걸로
		int[][] dp = new int[N + 1][1 << (N + 1)];
		
		// 초기화되지 않은 곳들은 무한대값 넣어두기
		for(int i = 0; i <= N; i++) {
			for(int j = 0; j < 1 << (N + 1); j++) {
				dp[i][j] = Integer.MAX_VALUE;
			}
		}
		
		// i번째 비트 켜기 : bit | (1 << i)
		// i번째 비트 끄기 : bit & ~(1 << i)
		// i번째 비트 확인 : bit & (1 << i)
		// 		i번째가 1인데 OR연산이니까 0이든 1이든 무조건 1이 된다
		// 		i번째만 0이고 그 아래가 다 1인데 AND연산이니까
		// 		그 아래는 0이면 0이고 1일때만 그대로 1이고, i번째는 0에 AND니까 0이 된다
		// 		AND연산이어서 bit의 i번째가 0이면 다 0이 된다
		

		
		// 처음에 0번 사람이 하나도 안 골랐을 때 값 0을 넣는다
		dp[0][0] = 0;
		
		// 0번 사람부터 N-1번 사람이 j조합의 일을 했을 때
		// 1~N의 일을 해서
		// 1번 사람부터 N번 사람까지 값을 최솟값으로 계속 넣어주기
		for(int i = 1; i <= N; i++) {
			
			// i-1사람이 j조합의 일을 했을 때에서 더해주자
			// 0번 사람에서 1번 사람으로 오기 위해서 0부터 시작한다
			for(int j = 0; j < 1 << (N + 1); j++) {

				// i-1사람이 일을 안 했다면 패스
				if(dp[i - 1][j] == Integer.MAX_VALUE) continue;
				
				// i-1번 사람의 j조합 값에서
				// 1~N 번의 일을 해서 최솟값 갱신으로 기록하자
				for(int k = 1; k <= N; k++) {

					// j조합의 일에 k번 일이 이미 있어서 0이 아니면 패스
					if((j & (1 << k)) != 0) continue;
					
					// k번 일을 한 값을 최솟값 갱신으로 기록
					// i-1사람이 j조합에서 일한 값에 + i사람이 k일을 한 값
					dp[i][j | 1 << k] = Math.min(dp[i][j | 1 << k], dp[i - 1][j] + costs[i][k]);
				}
				
			}
		}
		

		// N이 3일 때 1110의 경우의 수 : 1111에서 1을 뺀 값
		System.out.println(dp[N][(1 << (N + 1)) - 1 - 1]);
		
	}
}