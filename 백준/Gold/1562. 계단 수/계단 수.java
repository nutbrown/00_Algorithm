import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		// 길이가 N이면서
		// 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개인지
		int N = sc.nextInt();

		// 비트필드 다이나믹 프로그래밍 --------------
		// dp[길이][맨 끝 숫자][그동안 등장한 숫자 0~9]
		// 0~9 10자리 1111111111(2)를 담으려면
		// 피연산자의 비트열을 왼쪽으로 10번 옮긴 11자리수(1<<10)로 배열 크기 설정
		int[][][] dp = new int[N + 1][10][1 << 10];
		
		// 길이가 1인 수는 1개라고 초기값 입력
		for(int i = 1; i <= 9; i++) {
			dp[1][i][1 << i] = 1;
		}
		
		// 맨끝 숫자를 기준으로 뒤로 길이를 늘인다
		for(int i = 2; i <= N; i++) {
			
			// 길이가 i인데 끝숫자가 j인 계단수는
			// 길이가 i-1인데 끝숫자가 j-1인 수들에 j를 붙인 거 +
			// 길이가 i-1인데 끝숫자가 j+1인 수들에 j를 붙인 거 +
			for(int j = 0; j <= 9; j++) {
				
				// 숫자 0부터 9까지 사용하는 모든 경우의 수 -> 에서 더해준다 
				for(int k = 0; k < (1 << 10); k++) {
					
					// 붙이는 j가 0이면 j+1인 수에만 붙인다
					if(j == 0) {
						dp[i][j][k | 1 << j] += dp[i - 1][j + 1][k];
						dp[i][j][k | 1 << j] %= 1_000_000_000;
					}
					
					// 붙이는 j가 9면 j-1인 수에만 붙인다
					else if(j == 9) {
						dp[i][j][k | 1 << j] += dp[i - 1][j - 1][k];
						dp[i][j][k | 1 << j] %= 1_000_000_000;
					}
					
					// 그게 아니라면 다 붙인다
					else {
						// j-1에서 붙인 거, j+1에서 붙인 거 둘다 모듈러
						dp[i][j][k | 1 << j] += dp[i - 1][j - 1][k];
						dp[i][j][k | 1 << j] %= 1_000_000_000;
						dp[i][j][k | 1 << j] += dp[i - 1][j + 1][k];
						dp[i][j][k | 1 << j] %= 1_000_000_000;
					}
					
				}
			}
		}
		
		
		// [길이가 N이면서][ ][모든 숫자가 다 나와서 1 << 10 - 1]인 것들만 더하기
		int sum = 0;
		for(int i = 0; i <= 9; i++) {
			sum += dp[N][i][(1 << 10) - 1];
			sum %= 1_000_000_000;
		}
		
		System.out.println(sum);
	}
}